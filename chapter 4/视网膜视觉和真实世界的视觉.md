## 4.1.1	目标
在本节教程中，我们将介绍人类视网膜模型，它显示了一些有趣的图像预处理和增强特性，本教程中主要内容包括：

-	视网膜的两个主要通道
-	视网膜模型的基本使用
-	微调参数

## 4.1.2	总体介绍
模型的提出来源于Jeanny Herault在Gipsa的研究，其主要研究成果在论文Vision: Images, Signals and Neural Networks-Models of Neural Processing in Visual Perception中给出。它涉及到Listic(代码维护者和用户)实验室的图像处理应用程序。它不是一个完整的模型，但它的提出揭示了一些有趣的事情，可以应用到增强图像处理中。该模型允许使用以下人类视网膜特性：

-	光谱白化具有3个重要的效应：高频率信号抵消(噪声)、中频细节增强和低频亮度能量降低。
-	局部对数亮度压缩可以增强细节，即使在低光条件也可以增强细节。
-	细节信息和瞬态信息的去相关性。

接下俩对前两点特性进行详细说明：

在图4-1中，左侧图像是一个高动态范围的图像。为了使它能较为清晰的看见细节，将原始的输入图像线性的调整图像亮度范围，并转换为8bit/channel格式。因为太强烈的局部对比，这种较强的转换隐藏了许多细节。
 
<p align="center">
<img src="https://img-blog.csdnimg.cn/20200224120835276.png" height="300">
</p>

在图4-2中，一起应用局部亮度适应、空间噪声去除和光谱白化，就像你的视网膜一样，在较低范围的8位数据通道上传输准确的信息。在这张图片上，噪音被明显的被去除，局部细节被强烈的亮度对比所掩盖。输出图像保持自然，增强视觉内容。
<p align="center">
<img src="https://img-blog.csdnimg.cn/20200224121000879.png" height="300">
</p>
 
## 4.1.3	视网膜模型输出通道
视网膜模型有两种形式的输出：
-	第一个种叫做单细胞通道。它主要活跃于视网膜中央窝区(具有彩色感光感受器的高分辨率中央视觉)，其目的是为静止在视网膜上的视觉细节提供准确的彩色视觉。另一方面，模糊在视网膜上运动的物体。

-	第二个是Magnocellular通道。它主要活跃于视网膜周围视觉，并发出与变化事件(运动、瞬变事件等)相关的信号。这些输出信号还有助于视觉系统将视网膜聚焦在“瞬态”/移动区域进行更详细的分析，从而改进视觉场景上下文联系和对象分类。

注意：与真实的视网膜不同，我们用相同的分辨率将这两个通道应用于整个输入图像。这使得增强的视觉细节和运动信息可以应用在所有的图像种。但是，这两个通道是互斥的。例如，如果单细胞通道在一个区域提供了强大的能量，那么，由于存在瞬态事件，部分细胞通道肯定是模糊的。

为了说明这个问题，我们使用一个在较为黑暗环境种的相机采集的视频作为原始图像，分析视网膜模型中两个通道各起到什么作用。这个视频在一个大学的会场录制，里面有一些学生一边和老师交谈一边在移动。

在这个视频中，由于黑暗的环境，信噪比低，所以图像采集的质量较低，在视觉特征边缘上出现了虚假的色彩。具体形式如图4-3所示。

<p align="center">
<img src="https://img-blog.csdnimg.cn/20200224121200816.png" height="300">
</p>

之后将视网膜模型应用于图4-3，单细胞输出可以得到如图4-4所示的图片。在使用的视网膜配置中，全局亮度被保留，局部对比度被增强。此外，信噪比也得到了改善:由于高频时空噪声得到了降低，增强的细节不会被任何增强的噪声所破坏。

<p align="center">
<img src="https://img-blog.csdnimg.cn/20200224121316946.png" height="300">
</p>

继续输出Magnocellular通道的信息，输出结果如图4-5所示。当瞬态事件发生时，它的信号很强。当一个学生在图像的底部移动时，会产生高能量。其余的图像是静态的，但它是产生了一个强大的噪音。在这里，视网膜过滤掉大部分的噪音，从而产生低虚假运动区域的“警报”。这个通道可以用作瞬态/移动区域检测器：它可以为低成本的分割工具提供相关信息，从而突出显示事件发生的区域。

<p align="center">
<img src="https://img-blog.csdnimg.cn/20200224121508878.png" height="300">
</p>

## 4.1.4	代码教程
本教程使用的源码可以在opencv_folder/samples/cpp/tutorial_code/bioinspired/ retina_tutorial.cpp找到。视网膜模型在:cv::bioinspired名称空间命名空间中，因此一定要编译bioinspired模块，该模块需要依赖opencv_core (cv::Mat和friends对象管理)、opencv_highgui (显示和图像/视频读取)这两个基础库。我们可以分别用include包含这三个库，如代码清单4-1中所示。

```cpp
代码清单4-1：包含头文件
#include <opencv2/bioinspired.hpp>
#include < opencv2/core.hpp >
#include <opencv2/highgui.hpp>
```
程序中，首先声明一个cv::Mat矩阵，并加载输入图像。同时分配一个cv::VideoCapture对象准备加载视频流(如果必要)，这个过程在代码清单4-2中实现。

```cpp
代码清单4-2
int main(int argc, char* argv[]) {
    // declare the retina input buffer... that will be fed differently in 
    //regard of the input media
  	cv::Mat inputFrame;
  	cv::VideoCapture videoCapture; // in case a video media is used, its 
```

在处理之前，首先检查输入的命令参数。这里我们可以根据用户输入选择加载的数据类型，如果用户选择command –image，就加载图像，如果用户选择command –video就加载视频。

此外，如果用户在程序调用结束时添加log命令，那么由视网膜执行的空间对数图像采样将被布尔标志useLogSampling考虑在内。

```cpp
代码清单4-3
// welcome message
std::cout<<"*********************************************"<<std::endl;
std::cout<<"* Retina demonstration : demonstrates the use of is a wrapper class of the Gipsa/Listic Labs retina model."<<std::endl;
std::cout<<"* This demo will try to load the file 'RetinaSpecificParameters.xml' (if exists).\nTo create it, copy the autogenerated template 'RetinaDefaultParameters.xml'.\nThen tweak it with your own retina parameters."<<std::endl;
// basic input arguments checking
if (argc<2)
{
  	help("bad number of parameter");
  	return -1;
}
bool useLogSampling = !strcmp(argv[argc-1], "log"); // check if user wants retina log sampling processing
std::string inputMediaType=argv[1];
// checking input media type (still image, video file, live video acquisition)
if (!strcmp(inputMediaType.c_str(), "-image") && argc >= 3)
{
    std::cout<<"RetinaDemo: processing image "<<argv[2]<<std::endl;
    // image processing case
  	inputFrame = cv::imread(std::string(argv[2]), 1); // load image in RGB mode
}
if (!strcmp(inputMediaType.c_str(), "-video"))
{
    if (argc == 2 || (argc == 3 && useLogSampling)) // attempt to grab images from a video capture device
    {
        videoCapture.open(0);
    }
    else// attempt to grab images from a video filestream
    {
        std::cout<<"RetinaDemo: processing video stream "<<argv[2]<<std::endl;
        videoCapture.open(argv[2]);
    }
   	// grab a first frame to check if everything is ok
    videoCapture>>inputFrame;
}
else
{
    // bad command parameter
  	help("bad command parameter");
  	return -1;
}
```

检测图像是否被读取，如果没有，显示错误并停止程序。

```cpp
代码清单4-4
if (inputFrame.empty())
{
    help("Input media could not be loaded, aborting");
    return -1;
}
```
之后运行视网膜模型。在这里建议分配一个视网膜实例并管理最终的日志采样选项。视网膜构造器至少需要一个cv::Size对象来显示必须管理的输入数据大小。可以设置其他选项，如颜色及其相关的颜色多路复用策略(这里，Bayer多路复用使用enum cv::bioinspired::RETINA_COLOR_BAYER标志)。如果使用对数采样，可以调整图像简化系数(较小的输出图像)和对数采样强度。

```cpp
代码清单4-5
// pointer to a retina object
cv::Ptr<cv::bioinspired::Retina> myRetina;
// if the last parameter is 'log', then activate log sampling (favour foveal vision and subsamples peripheral vision)
if (useLogSampling)
{
    myRetina = cv::bioinspired::createRetina(inputFrame.size(), true, cv::bioinspired::RETINA_COLOR_BAYER, true, 2.0, 10.0);
}
else// -> else allocate "classical" retina :
    myRetina = cv::bioinspired::createRetina(inputFrame.size());
```

之后将参数写入一个包含视网膜默认参数的默认xml文件，用于创建模板。这里生成的模板xml文件称为RetinaDefaultParameters.xml。

```cpp
代码清单4-6
// save default retina parameters file in order to let you see this and 
//maybe modify it and reload using method "setup"
myRetina->write("RetinaDefaultParameters.xml");
```

之后，视网膜尝试加载另一个名为RetinaSpecificParameters.xml的xml文件。如果我们创建了它，并引入了自己的设置，它将被加载，或者我们可以使用默认的视网膜参数。

```cpp
代码清单4-7
// load parameters if file exists
myRetina->setup("RetinaSpecificParameters.xml");
```

创建一些输出缓冲区，准备接收两个视网膜通道的输出.

```cpp
代码清单4-8
// declare retina output buffers
cv::Mat retinaOutput_parvo;
cv::Mat retinaOutput_magno;
```

然后，在一个循环中运行视网膜，如果需要，从视频序列加载新帧，并将视网膜输出返回到专用缓冲区。

```cpp
代码清单4-9
// processing loop with no stop condition
while(true)
{
    // if using video stream, then, grabbing a new frame, else, input remains the same
    if (videoCapture.isOpened())
  	videoCapture>>inputFrame;
  	// run retina filter on the loaded input frame
  	myRetina->run(inputFrame);
  	// Retrieve and display retina output
  	myRetina->getParvo(retinaOutput_parvo);
   	myRetina->getMagno(retinaOutput_magno);
  	cv::imshow("retina input", inputFrame);
  	cv::imshow("Retina Parvo", retinaOutput_parvo);
  	cv::imshow("Retina Magno", retinaOutput_magno);
  	cv::waitKey(10);
}
```
